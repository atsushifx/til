---
title: 2025-06
layout: default
---

## 2025年6月分

### 2005年6月27日 -- ESTA開発 (text-parser, e2e-fixture-framework)

#### 作業概要

両パッケージはテキスト解析と E2E テストの効率化・品質向上を目的として開発されました。

- **text-parser パッケージ**では、ファイルベースの fixture テストを中心に、Markdown やプレーンテキストのパース機能とそれを検証する E2E テストフレームワークを構築。
  - シンプルな関数ベース設計を採用し、拡張子に応じた動的なパース処理を実装。
  - 動的テスト生成とバリデーションを分離し、保守性と拡張性を高めました。
  - 型安全性、コード品質、テストの安定性を徹底的に追求。

<!-- textlint-disable sentence-length -->

- **e2e-fixture-framework パッケージ**は、text-parser の依存関係を排除しつつ、BDD スタイルのユニットテストと E2E テストを含むクラスベースの堅牢なテストフレームワークに刷新。
  - 依存性注入により外部依存を断ち、プレフィックス命名で衝突を防止。
  - Vitest を活用した適切なモック設定やクロスプラットフォーム対応を施し、より高い品質を確保。
  - テストスタイルは `it()` を用いた BDD 形式で統一。

<!-- textlint-enable -->

---

#### 作業結果

- 両パッケージともに型エラーゼロ、ESLint やスペルチェッククリア、コードフォーマット自動整形完了。
- 全テストケース（text-parser: 20/20、e2e-fixture-framework: 21/21）合格を達成。
- e2e-fixture-framework は単独稼働可能で、柔軟なテスト注入と堅牢なカプセル化を実現。
- text-parser は YAGNI 原則に基づくシンプル設計ながら、拡張性の高いテストフレームワークとして完成。

---

#### 学習ポイント

1. **依存性注入の重要性**
   - 外部依存を排除し、テスト容易性とモジュール独立性を高める手法が効果的。

2. **型安全とコード品質の両立**
   - TypeScript の`as const`やジェネリクスを活用し、堅牢で安全なコード設計が可能。

3. **テストスタイルの統一と可読性向上**
   - BDD 形式(`it()`)に統一し、テスト仕様がわかりやすく保守しやすくなる。

4. **シンプル設計の価値**
   - クラス過多を避け関数ベースで段階的に機能追加することで、柔軟かつ効率的な開発を実現。

5. **モック設定の正確さ**
   - Vitest での適切なモック設定は、TypeScript のアンチパターン回避とテスト信頼性向上に寄与。

6. **包括的検証ワークフロー**
   - 複数次元（テスト、Lint、スペルチェック、フォーマット）での品質管理により、高いコード信頼性を達成。

---

#### 学びと気づき

- 小さなステップでの Red-Green-Refactor を守ることが、安定的で保守しやすいテスト開発に繋がる。
- fixture テストの分離と自動化により、テストカバレッジと品質保証が効率化される。
- クラス設計は必要な場面に限定し、基本はシンプルな関数ベースで十分。
- 依存関係を明確にし注入可能にすることで、モジュールの独立性と拡張性が大幅に向上。
- BDD スタイルのテスト記述は、他の開発者が仕様を理解しやすくし、チームでの協力を促進。
- クロスプラットフォーム対応やモックの適切な扱いが、テストの信頼性とメンテナンス性に直結することを再認識。

---

これらの成果は両パッケージの品質と開発効率向上に大きく寄与し、今後の機能追加や拡張にも柔軟に対応可能な基盤を築きました。

### 2005年6月26日 -- E2Eフレームワークの開発、ドキュメント整備

#### 1. リポジトリと対象ソース

- 対象は GitHub リポジトリの `@ag-utils/e2e-framework` パッケージ
  <https://github.com/atsushifx/esta/tree/main/packages/%40ag-utils/e2e-framework>

#### 2. 主な作業内容

- E2E（エンドツーエンド）テスト用ファイル入出力（File I/O）フレームワークの開発・リファクタリング
- ファイル操作の async/await 対応、ファイル形式の型安全な読み込み機能追加
- 環境変数の管理ヘルパーや、同期・非同期処理の統合ユーティリティの実装
- テストコードの統合と厳密化により信頼性の向上
- ESLint や commitlint などの設定を整備、CI 環境での安定稼働をサポート

#### 3. 開発者向けドキュメントの作成

- フレームワーク利用・開発のための日本語開発者ガイドを包括的に作成
- 以下のようなガイドを整備
  - コアコンセプトと Hello World テスト例の紹介（01-overview.ja.md）
  - 環境構築および基本的なテスト実行の手順（02-getting-started.ja.md）
  - ファイル・ディレクトリ操作の主要 API とエラーハンドリング解説（03-usage.ja.md）
  - 各 API メソッドのリファレンス（04-api-guide.ja.md）
  - よくある質問や問題対処（09-faq.ja.md）
- ドキュメント整備でフレームワークの習得コストを大幅に軽減し、チームでの共有を促進

#### 4. コミット・PR管理

- 多数の細かい変更を機能・編集種別に整理・統合してコミットログをきれいに管理
- PR には主にフレームワーク改善、テスト統合、環境整備のポイントを記載しマージ

#### 学び・気づき

- ドキュメント整備は開発効率と品質向上に不可欠、特に新規チームメンバーの理解促進に効果的
- Git の rebase や VSCode の Git ツールを駆使してコミット履歴を美しく保つことが重要
- ファイル I/O まわりの非同期化でテストの安定性とパフォーマンスが向上
- 開発者ガイドとコードの一体的なメンテナンスがプロジェクトの成熟に繋がる

#### 3人の感想

【小紅】
「こうやってドキュメントが整ってると、新しいメンバーも安心して触れるね♡ わたしもわかりやすくて嬉しいな〜」

【つむぎ】
「コードとドキュメントがちゃんと連動してるのはやっぱり大事。効率よく進められるし、バグも減るはず。」

【エルファ】
「環境整備や型安全性の向上は、私たちの安定稼働にも直結する。理想的な状態へと進化している。」

### 2005年6月25日 -- E2Eフレームワークの型安全なファイル操作システム設計とテスト構成最適化

#### 背景

ESTA プロジェクトの E2E テストフレームワークにおいて、ファイル拡張子の限定やマークダウン対応を
導入しつつ、型安全性と保守性を高めるための設計改善を実施。

---

#### 今日の作業まとめ

##### 1. ファイル拡張子とフォーマットの対応表設計

- `AG_E2E_FILE_FORMAT_MAP` による単一ソースから型を導出し、拡張子ごとに対応するフォーマットを定義
- 例: `json`/`jsonc` → `json`形式、`ts`/`js` → `typescript`形式、`md` → `markdown`、`txt` → `text`
- 型安全なファイル読み込み (`readFileTyped`) を拡張子チェック付きで実装し、未対応拡張子はコンパイル/実行時に弾く

##### 2. フレームワークのコードリファクタリング

- `FileIoFramework` を `AgE2eFileIOFramework` にリネームし、関連する型定義・インポートも更新
- 不要コメント削除やインポート整理など細かいコードクリーンアップを実施
- ファイル読み書きユーティリティの拡充（Markdown、Text の書き込み対応）と統一されたフォーマットパラメータの採用

##### 3. テスト設計の見直しと移行

- 既存のユニットテストから E2E テストへ適切に移行（環境管理、設定管理、内容比較など）
- 重複テストを削減し、ユニットは細部ロジック、E2E は統合的動作確認にフォーカス
- 未使用の型定義ファイル削除でコードベースをクリーン化
- 全体で 43 テスト（ユニット 24＋E2E19）が正常に動作し、テストの役割分担を明確化

##### 4. コード品質維持

- ESLint, 型チェック、Lint 順序修正を含むコード品質チェックを実施
- 設定ファイル（ls-lint.yaml, eslint.projects.js など）も更新し、ディレクトリ命名規則の緩和や tsconfig 追加など

---

#### みんなの感想

<!-- textlint-disable sentence-length -->

- **エルファ**:
 「単一の対応表から複数の型を導出して重複排除する設計は理にかなっている。
  　型安全性が上がれば不具合も減るから効率的だわ。でも細部の整合性はちゃんと確認しないとね…」

- **小紅**:
 「テストの重複を減らして役割分担を明確にしたの、すごくわかりやすい！
  　ユニットテストは細かくて早くて、E2E は実際の動きをちゃんと見る感じが好き。
  　未使用ファイルの削除もスッキリしてて、メンテナンス楽になりそう！」

- **つむぎ**:
 「コード品質チェックやインポート整理みたいな地味だけど大事な作業がちゃんと入ってて好感持てる。
  　あと Markdown や Text の読み書き対応が増えたのはユーザー体験的にも嬉しいよね。
  　型の統一で将来の拡張も楽になるし、堅牢な設計だと思うよ。」

<!-- textlint-enable -->

---

### 2025年6月26日 -- ESTAプロジェクト開発 (E2Eフレームワーク整備)

### 2025年6月24日 -- ESTAプロジェクト開発 (config-loader設計改善, e2eフレームワーク分割)

#### 1. E2Eフレームワーク分割とパッケージ設計

- ファイル入出力による e2e フレームワークを 1 パッケージ化
- ESTA 内 1 パッケージに集約し、ファイル入出力、セットアップ、クリーンアップ、fixture 対応を包括的に管理
- Vitest や Jest の`beforeEach`/`afterEach`で使いやすい API 設計を心がける
- パッケージ命名は`@ag-utils/e2e-framework`がバランス良くおすすめ
- 将来的にテスト関連パッケージ増加なら`@ag-unittest`名前空間を検討

#### 利用例（Vitest）

```ts
beforeEach(async () => {
  await setupFixture(FIXTURE_DIR, TEST_DIR);
});
afterEach(async () => {
  await removeFile(`${TEST_DIR}/testFile.json`);
});
```

### 2. config-loaderの分割設計ポイント

- config-loader を別パッケージ化
- 拡張子ごとにパース処理を分離し将来の拡張性を確保
- 責任範囲や拡張性で柔軟に判断

### 3. GitHub Actions (GHA) キャッシュ活用

- パッケージを lint するアクションにキャッシュを追加
- キャッシュディレクトリの他に、lib/module のようなビルド結果もキャッシュ
- キャッシュキーは`pnpm-lock.yaml`のハッシュと Node.js バージョンを組み合わせて精度を高める
- Shell スクリプトでのファイル名や変数はダブルクォートで囲い、ShellCheck 警告を回避

#### 4. package.jsonの"types"条件警告について

- `"exports"`内の`"import"`と`"require"`条件の後に`"types"`条件があると警告が発生
- Node.js は`"import"`と`"require"`を優先評価し、後の`"types"`は無視される
- 同じ階層の`import`, `require`, `types`の順番を変更し、警告を回避

##### 例

````json
"exports": {
  ".": {
    "types": "./lib/types/index.d.ts"
    "import": "./module/index.js",
    "require": "./lib/index.js",
  }
}

- `types`を`import`, 'require'の前で設定

### 2025年6月13日 -- オンボーディングドキュメント整備

#### ✅ monorepo構成と設定ファイルの共通化整理

- 🔧 全体像の把握とドキュメント構造の再設計
  - `/shared/configs/` を中心とした設定ファイル共通化構造の図解レビュー
  - `tsconfig.json` は monorepo ルート／各サブレポジトリで `extends` による共通化
  - `lefthook.yml` のような**独立型設定ファイル**との対比を明確に整理

- 🗂 セクション構成の再編成
  - 配置パターンと参照形式（import/extends・同期コピー）で分類
  - セクション `7.3 共通設定`, `7.4 サブリポジトリ`, `7.5 monorepo` を明確に分離
  - 表の整理と情報粒度の統一（ファイル名／ツール／参照元／参照方法／補足）

### 2025年6月11日 -- 開発環境構築スクリプトの整備

#### 📌 目的

- 開発支援ツール (textlint, cspell など) の一括インストール用 PowerShell スクリプトを整理・共通化。
- 各種パッケージマネージャー (winget / scoop / pnpm / eget) に対応した統一的なラッパー関数を整備。
- `.vscode`, `.textlintrc.yaml` などの設定ファイル群をテンプレートから安全にコピーできるように。

#### ✅ 今日やったこと

##### 🔧 インストール用ライブラリ `AgInstaller.ps1` を実装・強化

- `Install-XXXXPackages`各関数を定義、実装: 各インストーラーにあわせてパッケージリストを渡すことでインストール。
- 引数とパイプ入力の両方に対応。
- コメント行 (`#`) は自動スキップ。
- `AgInstaller-*-BuildParams` で引数パースの一元化。

##### ✍ ドキュメント系スクリプト `install-doc-tools.ps1` の整備

- `textlint`および関連プラグイン、`markdownlint-cli2`, `cspell` などを一括インストール。
- `.textlintrc.yaml`などのドキュメント支援ツールの設定ファイルをテンプレートからコピー
- `.vscode` だけはルート直下へ、他は `configs/` 以下へ配置。
- `TemplateDir` が存在しない場合はコピー処理をスキップ。
- コピー先ディレクトリが存在しない場合は自動生成。

#### 💡 学びと気づき

- PowerShell 関数は `ValueFromPipeline` + `begin/process/end` パターンを使うと使い勝手が良い。
- `.vscode` だけを特例扱いすることで、エディタ設定が干渉しない構成にできた。
- `robocopy` は GUI 要素を省略すればログが静かでスクリプト向き。

---

## 📝 次にやること

- ドキュメント（README, 使用例, Config 構成など）を整備
- PR としてコード＋ドキュメントをまとめて提出する

### 2025年6月7日-- コミットメッセージ自動生成機能の調査、実装

#### 📌 今日やったこと

`appleboy/codegpt` を導入し、Lefthook のコミットメッセージ生成フックに組み込んだ。

#### 🛠 実施内容

<!-- vale Google.WordList = NO -->

1. `codeGpt`のインストール
   - `appleboy/codegpt` を GitHub Releases から取得
   - バイナリを $PATH に追加し、CLI ツールとして利用可能に

2. `codeGpt`の設定
   - './configs/codegpt.config.yaml'にモデル、言語などの設定を追加

3. `dotenvx`との連携
   - `dotenvx`を使用して、API キーを.env に暗号化
   - `dotenvx`の子プロセスとして、codeGpt を動かすことでメッセージを生成

4. lefthook に組み込み
   - lefthook の`prepare-commit-msg`フックに codeGPt を組み込み
   - `lefthook run`にてメッセージが生成されることを確認

#### 🔍 気づき・メモ

✅ CLI 版の CodeGPT は拡張よりも柔軟で CI 向き

- 非対話的に実行可能で、Git フックや CI スクリプトとの統合がスムーズ。
- `prepare-commit-msg`に組み込むことで、自動で Conventional Commits に沿ったメッセージ生成が可能になる。
- 入力元として diff や COMMIT_EDITMSG を使えるため、他ツールとの相性も良好。

<!-- vale Google.WordList = YES -->

### 2025年6月6日-- ESTA オンボーディングドキュメント完成／オンボーディングドキュメント紹介記事作成

#### ✅ オンボーディングドキュメントの main へのマージ

- `easy-setup-tools-action` プロジェクトにおける初期導入ドキュメント（`docs/onboarding/`）を本日 `main` ブランチへマージ。
- 各章は、プロジェクトの開発・構成・運用フローを順に理解できるように整理済み。
- セットアップスクリプトや共通設定の同期、環境変数の扱い方など、**1人プロジェクトでも意義のある構成管理戦略**を文書化。
- マージ後にブランチ削除と CI 確認も完了。

#### 📝 オンボーディング紹介用ブログ記事の執筆

- 記事タイトル:「1 人プロジェクトなのに、オンボーディングドキュメントを書いてみた」
- 主な内容:
  - なぜ 1 人プロジェクトでもオンボーディングドキュメントを書くべきか？
  - 実際に書いてみて得られた「戦略的な整理」の重要性
  - ドキュメント構成やリンク、コード例、補足解説を交えて紹介
- 最後に、プロジェクトを象徴する 3 人（エルファ・小紅・つむぎ）の挨拶で締めた。

#### 💡 気づき・学び

- ドキュメントを書くことで、頭の中の「構成・依存・目的」が明確化される。
- 実装と文章の往復でプロジェクト全体の粒度や責務が整理された。
- 「いつか他人が読むかも」ではなく、「未来の自分への説明書」としての価値が大きい。

---

Happy Hacking!
― エルファ・小紅・つむぎより

### 2025年6月5日-- ESTA 10章〜12章 ドキュメント作成

#### 10章 ドキュメント作成時のチェックツール

textlint、markdownlint、cspell などのドキュメント向けチェックツールの導入と設定を行ない、ドキュメントの品質と一貫性を確保する仕組みを整備した。

#### 11章 CI/CDでの自動検証ツール

GitHub Actions を用いたコード静的解析（ESLint）や機密情報漏洩検査（Gitleaks）などの自動検証ワークフローの構築と運用方法を解説し、将来的な拡張計画を示した。

#### 12章 コミット・プッシュ関連のツール

Lefthook による Git フック管理と commitlint によるコミットメッセージ規約チェックの設定・運用を通じて、開発時の品質管理とチームの開発ルール遵守を促進する仕組みを構築した。

#### 気づきとレトロスペクティブ

<!-- textlint-disable ja-spacing/ja-no-space-around-parentheses -->

- **エルファの視点**
  「自動化で品質管理が強化されたわ。だけど設定ファイルやワークフローの複雑さが増して、運用負荷も見逃せない。依存関係の整理とドキュメントの整備が重要ね。」

- **小紅の視点**
  「ツールを入れてチェックが増えたことで、うっかりミスが減って嬉しい！でもエラー時の対応やルールの理解はまだ慣れが必要かも。みんなで使いこなせるように工夫したいな。」

- **つむぎの視点**
  「仕組みがしっかりしていて効率的だけど、柔軟に拡張や修正ができる設計も求められるね。CI/CD とローカルチェックの整合性を保ちつつ、チーム全体での共有が鍵だと思う。」

<!-- textlint-enable -->

### 2025年6月4日-- ESTA開発: オンボーディング用ドキュメント作成

#### 🛡️ 概要（ライセンスと構成）

本日は、ESTA プロジェクトのオンボーディングドキュメントとして、第 7〜10 章（途中）を執筆。
パッケージ構成、スクリプト設計、コード／ドキュメント品質のルールを明文化。

プロジェクトは **MITライセンス** であり、`README`にはその旨と著作権表記の明示を記載した。
派生物においてもライセンスおよびコピーライトは保持されるよう記述した。

#### 各セクションの執筆概要

- 第7章: Monorepo 設計と pnpm 構成
  - `pnpm` による monorepo 管理方式とルートの役割、workspace 配下の構成方針を明記
  - パッケージ単位の依存解決、並列実行 (`-r`) への対応例を紹介
- 第8章: スクリプト運用とルール化
  - `package.json` のスクリプトを役割別に定義し、ドキュメントとして整理
  - 各パッケージで共通的に利用するためのスクリプト統合と命名規約も適用
- 第9章: コード品質チェックツール
  - 使用するツール群 (`eslint`, `prettier`, `stylelint`, `tsc`) の一覧と役割を記載
  - VSCode と統合した開発支援環境構築に関する補足記述も付属
- 第10章（前半）: ドキュメント品質チェック
  - `textlint`, `markdownlint`, `CSpell` によるドキュメント校正フローを明記
  - `allowlist`, `textlint-disable`, `prh` など例外処理の記法も記述
  - `pnpm run` による実行例・オプションも併記済み

#### 🌸 気づき

- ドキュメントもコードと同等の Lint 対象として整備すべきという意識が強まった
- ツール群の構成とスクリプト命名で迷わなくなる恩恵が大きい

#### 🔁 レトロスペクティブ（3人視点）

【エルファ】

> 「ライセンス条項の明記完了。READMEと/LICENSEの相互参照による整合性は確認済み。……マスターの作業は、法的にも隙がありません。」

【小紅】

> 「こべに、校正ツールって地味かなって思ってたけど……エラーの無視とか、許可リストとか、ちゃんと書き方あってすごかったですっ！🥺センパイに教えてもらって、賢くなった気がするぅ〜💖」

【つむぎ】

<!-- vale Google.WordList = NO -->

> 「ふふ……“textlint-disable”とかって、使い方間違えるとダサいのよね〜。でもセンパイの書き方見たら、あーしも真似したくなっちゃった……ちゃんと理由つけて、賢いって感じ〜♡」

<!-- vale Google.WordList = YES -->

### 2025年6月3日-- ESTA開発: オンボーディング用ドキュメント作成

#### パッケージマネージャー導入フロードキュメント作成

- **Volta / pnpm / scoop / winget** のセットアップ手順を整理
- Volta による Node.js / pnpm のバージョン管理と環境変数の設定を明記
- `pnpm` グローバルインストール時の `global-bin-dir`の**Path追記**を明示

#### 気づき

- `pnpm config get global-bin-dir`の出力を`Path`に反映する必要あり
- `volta` は PowerShell 再起動しないと反映されないことがあるため、再起動指示は必須。
- 一見「当たり前」な手順こそ、新規参加者のつまずきポイントになるため、丁寧なドキュメントが重要。

### 2025年6月2日 -- ESTA開発: errorによる実行制御の要件定義

#### 🔧 今日のテーマ

<!-- vale Google.WordList = NO -->

プロセス終了処理 (`process.exit`) の一元化とログ出力・exitCode 制御の分離
CLI / Node.js ツールにおける「異常終了」と「制御可能エラー」の切り分け設計を行なった。

#### ✅ 導入する構成と機能

### 1. `fatalExit(code, message)`

- 標準エラー出力にログを出力
- 即時 `process.exit(code)`
- 制御は戻らず強制終了

### 2. `errorExit(code, message)`

- カスタム例外 `ExitError` を throw
- 上位で `try...catch` により補足・制御可能

#### 📦 `ExitError` の実装

- `Error` を拡張
- `code: ExitCode` を保持
- `instanceof` 判定・stacktrace 対応済み

#### 🔢 `ExitCode` enum の管理

```ts
export enum ExitCode {
  SUCCESS = 0,
  ERR_UNKNOWN = 1,
  ERR_CONFIG_NOT_FOUND = 2,
  ERR_COMMAND_EXECUTION = 3,
  ERR_INVALID_ARGS = 4, // ← 追加
}
````

#### 📊 errorLevel グローバル構想

- `Log.error()` 時に `errorLevel` を記録
- `errorLevel > 0` で最終的に `fatalExit(errorLevel)`
- ログ出力にはログレベル不要、処理判断目的に限定

#### 📁 構成方針

| 要素                  | パス案                                                 |
| --------------------- | ------------------------------------------------------ |
| fatalExit / errorExit | `@ag-system/exit-handlers`                             |
| ExitCode 定義         | `@shared/types/exitCode.ts`                            |
| ExitError クラス      | `src/system/ExitError.ts` or `src/errors/ExitError.ts` |

## 📝 所感・補足

<!-- vale Google.WordList = NO -->

- `throw` によるエラー制御は柔軟かつ再利用性が高い
- fatal と error の二層構造で CLI の信頼性向上
- enum によるエラーコードの定義はロギング・CI との連携に有効

---
